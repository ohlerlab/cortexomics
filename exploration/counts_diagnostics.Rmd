## dispersion plot

```{r}
DESeq2::plotDispEsts(dds)
```


## detection of outliers

The DESeq function calculates, for every gene and for every sample, a diagnostic test for outliers called Cook’s distance. Cook’s distance is a measure of how much a single sample is influencing the fitted coefficients for a gene, and a large value of Cook’s distance is intended to indicate an outlier count. The results function automatically flags genes which contain a Cook’s distance above a cutoff for samples which have 3 or more replicates. The p values and adjusted p values for these genes are set to NA. At least 3 replicates are required for flagging, as it is difficult to judge which sample might be an outlier with only 2 replicates.

The default Cook’s distance cutoff for the two behaviors described above depends on the sample size and number of parameters to be estimated. The default is to use the 99% quantile of the F(p,m − p) distribution (with p the number of parameters including the intercept andmnumber of samples). 

```{r}
boxplot(log10(SummarizedExperiment::assays(dds)[["cooks"]]), range=0, las=2)
```

## distribution of counts

```{r warning=F}
my_counts <- 
  DESeq2::counts(dds)%>%
  as.data.frame() %>%
  tibble::rownames_to_column("feature_id") %>% 
  tidyr::gather(sample_id, count, -feature_id) 
my_counts <-
dplyr::left_join(my_counts, dplyr::select(sample_annot, sample_id, sample_name, group), by = "sample_id") 

my_counts %>%
  ggplot(aes(x = count + 1e-3, color = group, group = sample_name)) + 
  geom_density() +
  scale_x_log10()

my_counts %>%
  dplyr::arrange(group) %>%
  dplyr::mutate(sample_name = factor(sample_name, levels = unique(sample_name))) %>%
  ggplot(aes(y = count + 1e-3, color = group, x = sample_name)) + 
  geom_violin() +
  scale_y_log10() +
  coord_flip()
```


## pca

```{r cache = T}
rld <- DESeq2::rlog(dds, blind = TRUE)
DESeq2::plotPCA(rld, intgroup=c("group"))
```


## regularized log transformed counts

For selecting the top regulated genes and clustering them we will use the regularized log transformed data as provided by DESeq2. Below we show the standard deviation vs the mean of these regularized counts: Due to the regularization (shrinkage/moderation) the high dispersion of the low count genes is strongly reduced. Hence we can rank the genes according to the standard deviation and then select the top genes for further treatment.

```{r}
rld_df <- get_reg_log_counts(dds, blind = T)

rld_dispersion <-
rld_df  %>%
  dplyr::group_by(feature_id) %>%
  dplyr::summarise(mean_reg_log_count = mean(reg_log_count),
            sd_reg_log_count = sd(reg_log_count))

rld_dispersion %>%
ggplot(aes(y = sd_reg_log_count, x = mean_reg_log_count)) + 
  geom_point() +
  labs(x = "mean log regularized counts", y = "standar deviation log regularized counts")
```

## heatmap of top fluctuating genes

Before clustering, we scale and center the counts for each gene, and in a second step set all values smaller than `r z_min` to `r z_min` and all values larger than `r z_max` to `r z_max`. Samples and genes are then clustered using $1 - cor(x,y)$ as a distance.

```{r}
plot_heatmap_fluc_features(500, rld_df, z_min = z_min, z_max = z_max)
```
