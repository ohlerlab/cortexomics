###This was just a sketch for my bachelors student


REF=hg19.fa

rule gffread:
  input: REF,GTF_orig
  output: GTF,CDSGTF,RNAFASTA,CDSFASTA,BED,chromsizes,trsizes
  run:
    shell(r""" 
      # set -x
      #with filtering output all sequences
      cat {GTF_orig} \
      > {GTF}

      cat {GFF_orig} \
      > {GFF}
      #needs gff - output exon sequences
      cat {GFF_orig} \
      |  grep -P -e'\texon\t|^\#' | 
      gffread - -F -E -g {REF} -W -w {RNAFASTA} -o /dev/null

      samtools faidx {RNAFASTA}
      cut -f1,2 {RNAFASTA}.fai  > {trsizes}    
      """)

rule create_mappability_reads:
  input: trsizes,RNAFASTA
  output: 'trim_reads/mappability_{kmer}/mappability_{kmer}.fastq.gz'
  threads: 8
  shell: r"""
  #do this for entire genome
  set -x
  #these one liners, in order, cat the chromosome sizesinto awk to create bed files spanning the chromosomes, 
  #create fastas from a bed file, stick together every second line, generate the tiles of kmer size, modify the names of hte
  #tiles, and then finally turn them into fastq format
 
  cat {trsizes} \
    | awk '{{print $1"\t"1"\t"$2}}' \
    | bedtools getfasta -s -fi {RNAFASTA} -bed -  \
    | sed '$!N;s/\n/ /' \
    | perl -lane '$i=0;while($i<=(length($F[1])-{wildcards.kmer})){{print $F[0] , "$i\n", substr $F[1],$i,{wildcards.kmer} ; $i = $i +1}}' \
    | perl -lan -F'[\:\-|\)|\(]' -e 'if( /^>/){{print $F[0],"_",$F[1]+$F[4],"_",$F[1]+$F[4]+{wildcards.kmer}}}else{{print @F}}' \
    | perl -lanpe 's/>/@/ ; s/^([^@]+)/\1\n+/; if($1){{$a="I" x length($1); s/\+/+\n$a/}}' \
    | gzip > {output}
    """


rule createmappability_bedgraph:
  # input: 'mappability/mappability_{kmer}.bam'
  input: 'star/data/mappability_{kmer}/.done',trsizes
  output: 'mappability/mappability_{kmer}.bedgraph'
  conda: '../envs/bedgraphtobigwig'
  params:
    bam = lambda wc: 'star/data/mappability_'+str(wc['kmer'])+'/mappability_'+str(wc['kmer'])+'.bam'
  threads: 8
  shell: r"""
  trap "set -x; rm -rf ${{MY_TMP_DIR}}" EXIT KILL TERM INT HUP

  MY_TMP_DIR=$(mktemp -d)
  mkdir -p $MY_TMP_DIR
  MY_TMP_DIR='mappatest'
 
  set -x

  samtools view -h {params.bam}  | sed -e '/^@PG/Q' \
   | cut -f 2,3 | sed 's/[SL]N://g' | sed 's/ /_/g' \
   | tail -n+2 >${{MY_TMP_DIR}}/chrsizes

  samtools view {params.bam} \
    | grep -ve 'NH:i:1' \
    | awk -vFS="_" -vOFS="\t" '{{print $1,$2-1,$2}}' \
    | uniq \
    | bedtools sort -i /dev/stdin -faidx {trsizes} \
    | bedtools merge  -prec 1 \
    | awk -vOFS="\t" '{{print $0,1}}' > {output[0]}

"""


#then this r code to use the resulting bedgraphs

#load the cds
cds <- import(here('pipeline/my_gencode.vM12.annotation.cds.gtf'))
exons <- import(here('pipeline/my_gencode.vM12.annotation.gtf'))%>%subset(type=='exon')
#we need the cdsd to be 
cdsmap<-cds%>%setNames(.,as.character(.))%>%mapToTranscripts(exons%>%split(.$transcript_id))
mcols(cdsmap) <- mcols(cds)[cdsmap$xHits,]
#load the tracks
mappatrack <- import(here('pipeline/mappability/mappability_27.bedgraph'))
#add CDS
seqinfo(mappatrack) <- seqinfo(cdsmap)[
  c(seqinfo(mappatrack)@seqnames,setdiff(seqinfo(cdsmap)@seqnames,seqinfo(mappatrack)@seqnames)),]

mappatrack%<>%coverage(weight='score')

cdssamp <- cdsmap%>%sample(1000)

stop()

cdsmap$nomapbases <- mappatrack[cdsmap]%>%mean