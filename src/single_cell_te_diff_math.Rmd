---
title: "fractions"
author: "Dermot Harnett"
date: "4/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
cond 1
mRNA 15 15
_ 
Ribo 10 20    

Cond 2
mRNA 10 20
Ribo 6 24





cond 1
mRNA 30 30
_ 
Ribo 20 40    

Cond 2
mRNA 20 40
Ribo 12 48





so the proportion of reads thats from cell type B in each library is:
  
M_1_b_mRNA=    1 / (1+1*p1)  = 0.5
M_1_b_Ribo=    1 / (1+1*T*p1) = 2/3

M_2_b_mRNA=    1 / (1+1*p2) = 2 / 3

M_2_b_Ribo=    1 / (1+1*T*p2) = 

The probability of a random read coming from gene i in a library m is

e_a * (1-M_2_b_Ribo) +  e_b * (M_2_b_Ribo)


so e.g. if e_1 is 1 and e_b is 2

#faxtorized
cond 1
mRNA 3.5 3.5
_ 
Ribo 2.5 2.2.5    

Cond 2
mRNA 2.5 2.2.5
Ribo 2.3 2.2.2.3

#I plan to mulitply all the ell b numbers by a_b, which is a fraction, so they all need to have that as a factor
cond 1
mRNA 3.5 3.5
_ 
Ribo 2.5 2.2.5    

Cond 2
mRNA 2.5 2.2.5
Ribo 2.3 2.2.2.3

#mult two to all of em
cond 1 
cell    A     B
mRNA (15)45k (30)45k
Ribo (10)30k (40)60k    

Cond 2
cell   A      B
mRNA (10)30k (40)60k
Ribo (6)18k (48)72k

mRNAFC = (10+40) / (15+30)
RiboFC =  (6+48) / (10+40)

'mRNAFC = (10+40) / (15+30)  = 50/45 = 10/9 = 1.111'
'RiboFC =  (6+48) / (10+40) = 54 / 50 = 27/25 = 1.08'

TEFC = RiboFC - mRNAFC

```


```{r pressure, echo=FALSE}
eratio = 2
a_a = 1/3
a_b = ediff * a_a
tediff = 1

cellratio_1 = 1
p_ratio_1 = cellratio_1 * tediff
p_a_1 =  1 / (1+  p_ratio_1)
p_b_1 = 1-p_a_1

cellratio_2 = 2
p_ratio_2 = cellratio_2 * tediff
p_a_2 =  1 / (1+  p_ratio_2)
p_b_2 = 1-p_a_2

N=90
a_a * p_a_1*N
a_b * p_b_1*N

a_a*p_a_2*N
a_b*p_b_2*N
(a_a*p_a_2 + a_b*p_b_2) / (a_a * p_a_1  + a_b * p_b_1)  

OR

(p_a_2 + eratio*p_b_2) / (p_a_1  + eratio * p_b_1)  

OR

( 1 / (1+  cellratio_2 * tediff) + eratio* cellratio_2 * tediff / (1+  cellratio_2 * tediff)) / ( 1 / (1+  cellratio_1 * tediff) + eratio* cellratio_1 * tediff / (1+  cellratio_1 * tediff))
OR

C_2 = 2
C_1 = 1
E = 2
T = 2

#this works in wolfram
( 1 / (1+  C_2 * T) + E* C_2 * T / (1+  C_2 * T)) / ( 1 / (1+  C_1 * T) + E* C_1 * T / (1+  C_1 * T))

fc <- function(E,T,C_1,C_2)( 1 / (1+  C_2 * T) + E* C_2 * T / (1+  C_2 * T)) / ( 1 / (1+  C_1 * T) + E* C_1 * T / (1+  C_1 * T))

fc(3,2,1,2)#Riboseq
fc(3,1,1,2)#mRNA

fc(3,2,0,3)-fc(3,1,0,3)#TE

lapply( seq(1,5,by=0.2),function(E) (fc(E,0.5,0,3)-fc(E,1,0,3))/fc(E,1,0,3))#TE)


#can I simplify further
T=1; ( 1 / (1+  C_2 * T) + E* C_2 * T / (1+  C_2 * T)) / ( 1 / (1+  C_1 * T) + E* C_1 * T / (1+  C_1 * T))
C_1 = 0 ; T=2; ( 1 / (1+  C_2 * T) + E* C_2 * T / (1+  C_2 * T)) / ( 1 / (1+  C_1 * T) + E* C_1 * T / (1+  C_1 * T))
C_1 = 0 ; T=1; ( 1 / (1+  C_2 * T) + E* C_2 * T / (1+  C_2 * T)) / ( 1 / (1+  C_1 * T) + E* C_1 * T / (1+  C_1 * T))

T=3; ( 1 / (1+  C_2 * T) + E* C_2 * T / (1+  C_2 * T)) / ( 1 / (1+  C_1 * T) + E* C_1 * T / (1+  C_1 * T))

#wolfram text (1/(1 + C_2 T) + e C_2×T/(1 + C_2 T))/(1/(1 + C_1 T) + e C_1×T/(1 + C_1 T))


#er = 2 ; Mr_1 = cr_1 * tr ; Mr_2 = cr_2 * tr ; fr[_x] := (x/(1+x)) ; simplify  fr[Mr_1]
#Wolfram can't read that

#what about simple ase where C_1 =0
#put this in ( 1 / (1+  C_2 * T) + E* C_2 * T / (1+  C_2 * T)) / ( 1 / (1+  0 * T) + E* 0 * T / (1+  0 * T))

#use a as variable ( 1 / (1+  C_2 * T) + (A* C_2 * T) / (1+  C_2 * T)) / ( (1 / (1+  C_1 * T)) + (A C_1 * T) / (1+  C_1 * T))  

#Use 
T=2
A = E
C_1=1
C_2=2

((C_1 *T + 1) *(A *C_2* T + 1))/((C_2 *T + 1)* (A *C_1* T + 1))
#This does work


#We acn also extend this to more than one case
(p_a_2 + eratio*p_b_2) / (p_a_1  + eratio * p_b_1)

#Then our ratio is 
E(c)[ p_c * e_c  ] / E(c)[ p_c * e_c  ]#excpected value ovre all cells
E(c)[ n_c * t_c * e_c  ] / E(c)[ p_c * t_c * e_c  ]#excpected value ovre all cells
#normalized so that the sum over all e,  and c values is 1





```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
