
```{r }
source(here('src/R/Rprofile.R'))
```

---
title: "Sequence specific offset determination"
author: "Dermot Harnett"
---

```{r setup, include=FALSE, echo=FALSE, eval=T}
knitr::opts_chunk$set(root.dir = here::here(),eval=FALSE,cache=FALSE,echo=FALSE,warning = FALSE,message = FALSE,include=FALSE)



# suppressMessages({library(svglite)})
suppressMessages({library(readr)})
suppressMessages({library(Biostrings)})
suppressMessages({library(Rsamtools)})
#suppressMessages({library(psd)})
suppressMessages({library(txtplot)})
suppressMessages({library(rtracklayer)})
suppressMessages({library(stringr)})
suppressMessages({library(data.table)})
suppressMessages({library(assertthat)})
suppressMessages({library(parallel)})
suppressMessages({library(dplyr)})
# suppressMessages({library(riboWaltz)})
suppressMessages({library(purrr)})
suppressMessages({library(here)})
suppressMessages({library(magrittr)})
suppressMessages({library(stringr)})
suppressMessages({library(tidyverse)})
suppressMessages({library(GenomicAlignments)})
suppressMessages({library(GenomicFeatures)})
suppressMessages({library(GenomicFiles)})
suppressMessages({library(bamsignals)})
suppressMessages({library(memoise)})
suppressMessages({library(here)})

reduce <- GenomicRanges::reduce

MAPQTHRESH <- 50



# purely(function(){
STOPWINDOWSTART= -2
STOPWINDOWEND= 2


string2onehot<-function(scol) vapply(c('A','C','T','G'),function(lev)as.numeric(scol==lev),rep(1,length(scol)))
dnaseq2onehot <- function(mat,pre){
	mat<-as.matrix(mat);
	lapply(1:ncol(mat),function(n) string2onehot(mat[,n])%>%set_colnames(paste0(pre,n,'.',colnames(.))))%>%purrr::reduce(cbind)
}


get_transcript_compartments<-function(topcdsexons,compartments){
	#add compartment to the mapped reads
	trcomps<-data_frame(chr=as.character(topcdsexons@seqnames),transcript_id=topcdsexons$transcript_id)%>%
		mutate(compartment=compartments[chr])%>%
		# distinct(transcript_id,compartment)%>%
		{setNames(CharacterList(as.list(.$compartment)),.$transcript_id)}%>%
		unlist
	trcomps
}

get_cdsread_trmap <- function(topcdsreads,topcdsexons,topcdsmap){
	stopifnot('compartment' %in% colnames(mcols(topcdsexons)))
	#reads as a gr
	topcdsreadsgr<-topcdsreads%>%as("GRanges")
	#get the shifts and store in hte gr
	topcdsreadsgr$length<-qwidth(topcdsreads)
	#now map these to transcript space
	cdsread_trmap<-topcdsreadsgr%>%splitmaptotranscripts(topcdsexons)

	# testwidde<-cdsread_trmap%>%subset(width>40)%>%.[1])
	cdsread_trmap$length<-topcdsreadsgr$length[cdsread_trmap$xHits]

	cdsread_trmap$compartment<-topcdsexons$compartment[cdsread_trmap$transcriptsHits]

	#select only those which mapped cleanly onto transcripts
	cdsread_trmap%<>%trim
	cdsread_trmap<-cdsread_trmap%>%subset(width==length)

	starcods_trmap <- topcdsmap%>%resize(3,ignore.strand=TRUE)%>%setNames(.,as.character(seqnames(.)))

	cdsread_trmap$phase <- ((start(cdsread_trmap) - start(starcods_trmap[seqnames(cdsread_trmap)])) %%3)


	assert_that({
		non3ttr<-coverage(cdsread_trmap)[topcdsmap]%>%lengths%>%map_dbl(`%%`,3)%>%.[.!=0]%>%names;
		length(non3ttr)==0#all the cds should be multiples of 3
	})

	assert_that(has_name(mcols(cdsread_trmap),c('length','compartment','phase')))

	cdsread_trmap

}%>%purely


#for now let's not consider base pairs with no strong pwm


get_offsets<-function(cdsread_trmap,compartments){

	readsizes <- select_toplengths(cdsread_trmap$length)

	possibleoffsets <-seq(6,max(readsizes),by=3)%>%setNames(.,.)

	offset_cds_scores <- lapply(possibleoffsets,function(offset){
		lapply(unique(compartments),function(compartment_i){
			lapply(readsizes,function(length){
				lapply(0:2%>%setNames(.,.),function(phase_i){
					if((length - 6 - offset) < 0) return(data_frame(score=NA))
					cat('.')
					cdsread_trmap%>%
						subset(compartment==compartment_i)%>%
						subset(phase==phase_i)%>%
						subset(length==length)%>%
						resize(1,'start',ignore.strand=T)%>%
						shift(offset)%>%
						countOverlaps(topcdsmap)%>%
						`>`(0)%>%sum%>%data_frame(score=.)
				})%>%bind_rows(.id='phase')
			})%>%bind_rows(.id='length')
		})%>%bind_rows(.id='compartment')
	})%>%bind_rows(.id='offset')%>%
	mutate_at(vars(everything()),as.numeric)%>%
	mutate(compartment=unique(compartments)[compartment])

	bestscores<-offset_cds_scores%>%group_by(length,phase)%>%slice(which.max(score))

	list(bestscores,offset_cds_scores)
}

#define compartments
get_compartments<-function(cds,circs=DEFAULT_CIRC_SEQS){
	compartments <- rep('nucl',length(seqlevels(cds)))%>%setNames(seqlevels(cds))
	circs_in_data <- intersect(circs,names(compartments))
	compartments[circs_in_data] <- circs_in_data
	compartments
}
```

- select the ones that have the best score for each length and phase

```{r }
#We now have optimal offsets per readlength/phase


select_toplengths <- function(x) x %>%table%>%{./sum(.)}%>%keep(. > 0.05)%>%names%>%as.numeric%>%setNames(.,.)




#


apply_cds_offsets <- function(cdsread_trmap,bestscores){
	mcols(cdsread_trmap)%>%as.data.frame%>%left_join(bestscores,by=c('length','phase'))%>%.$offset
}


get_stop_sites <- function(reads_tr,topcdsmap,STOPWINDOWSTART,STOPWINDOWEND){
	setpos<- .%>%{strand(.)<-'+';.}

	prestops <- topcdsmap%>%setpos%>%resize(3,'end')%>%resize(1,'start')%>%setNames(seqnames(.))
	starts <- topcdsmap%>%setpos%>%resize(1,'start')%>%setNames(seqnames(.))

	#all stop codons!
	# stopifnot(topExonseq[prestops%>%resize(3)%>%shift(3)]%>%translate%>%`==`('*'))

	#get the psites predicted to -+2 of the first nt of our pre-stop codons
	reads_tr$stop<-reads_tr%>%
		resize(1,'start')%>%shift(.$cdsshift)%>%{strand(.)<-'+';.}%>%
		overlapsAny(resize(prestops,5,'center'))

	#get the distance to the 1 site of the prestop
	reads_tr$stopdist<-start(reads_tr) - start(prestops[seqnames(reads_tr)])
	reads_tr$startdist<-start(reads_tr) - start(starts[seqnames(reads_tr)])

	stoppsites<-reads_tr%>%subset(between(stopdist,0,STOPWINDOWEND))%>%{.$dist<-.$stopdist;.}
	startpsites<-reads_tr%>%subset(between(startdist,STOPWINDOWSTART,0))%>%{.$dist<-.$startdist;.}

	c(stoppsites,startpsites)
}

get_seqforrest_traindata <- function(stoppsites,exonseq){

	stopifnot(c('stopdist','length') %in% colnames(mcols(stoppsites)))
	stopifnot(all(seqnames(stoppsites)%in%names(exonseq)))
	stopifnot(is(exonseq,'DNAStringSet'))

	startseq <- exonseq[stoppsites%>%resize(2,'start')%>%resize(4,'end')]
	
	endseq <- exonseq[stoppsites%>%resize(2,'end')%>%resize(4,'start')]

	seqmat <- cbind( dnaseq2onehot(startseq,'fp.'),dnaseq2onehot(endseq,'tp.'))

	seqmat%>%cbind(stopdist=stoppsites$stopdist,length=stoppsites$length)%>%as.data.frame

}

get_seqoffset_model <-  function(data4readshift){
	require(ranger)
	shiftforrestfit <- ranger::ranger(formula= factor(stopdist) ~ . ,
		data=data4readshift,
		importance='permutation'
	)
	shiftforrestfit
}

get_predictedshifts<-function(shiftforrestfit,data4readshift){mymemoise(predict)(shiftforrestfit,data=data4readshift)$prediction%>%as.character%>%as.numeric}
get_offsets<-mymemoise(get_offsets)

get_top_trs<-function(bam,exons,cds,startcods){
	#get counts over all cds
	cdsstren<-mymemoise(bamCount)(bam,cds)
	cds$count<-cdsstren
	trcounts<-cds$count%>%split(cds$transcript_id)%>%map_dbl(sum)


	#gene tr relationshiop df
	gtrdf<-exons%>%mcols%>%.[,c('gene_id','transcript_id')]%>%as.data.frame%>%distinct



	#' - For a given library, Now take the trancsript with the most overlaps, for the top 1k genes

	startcodcount <- startcods%>%.$transcript_id%>%table

	simpletrs<-startcodcount[startcodcount==1]%>%enframe%>%select(transcript_id=name)
	ccds <- cds%>%mcols%>%as.data.frame%>%select(transcript_id,tag)%>%filter(tag=='CCDS')%>%distinct
	stopifnot(nrow(ccds)>1e3)
	#get the tr with the highest signal per gene
	#get the tr with the highest signal per gene

	toptrs <- gtrdf%>%
		left_join(enframe(trcounts,'transcript_id','count'))%>%
		semi_join(simpletrs)%>%
		semi_join(ccds)%>%
		group_by(gene_id)%>%
		slice(which.max(count))%>%
		arrange(desc(count))%>%
		.$transcript_id%>%
		head(1e3)




	#' - Ensuring these have only 1 start codon, for simplicity

	topcds <- cds%>%
		subset(transcript_id %in% toptrs)%>%
		identity
		# head(1e3)

	topstartcods<-startcods[match(topcds%>%.$transcript_id%>%unique,startcods$transcript_id)]

	#get the exons for these
	topcdsexons <- exons%>%subset(transcript_id %in% toptrs)

	#' - Map our reads to these transcripts

	#mapped cds
	topcdsmap<-topcds%>%pmapToTranscripts(topcdsexons%>%split(.,.$transcript_id)%>%.[topcds$transcript_id])%>%reduce
	#also start codons
	starcods_trmap<-topstartcods%>%mapToTranscripts(topcdsexons%>%split(.$transcript_id))
	starcods_trmap%<>%setNames(as.character(seqnames(.)))
	return(list(topcdsexons,topcdsmap))
}



mimport<-mymemoise(function(...)rtracklayer::import(...))
mapToTranscripts<-mymemoise(GenomicFeatures::mapToTranscripts)
pmapToTranscripts<-mymemoise(GenomicFeatures::pmapToTranscripts)
readGAlignments<-mymemoise(GenomicAlignments::readGAlignments)
splitmaptotranscripts <- mymemoise(function(reads,transcripts) reads%>%split(.,ceiling(seq_along(.)/ 50e3))%>%lapply(.%>%mapToTranscripts(transcripts%>%split(.$transcript_id)))%>%Reduce(f=c))

fp <-function(gr)ifelse(strand(gr)=='-',end(gr),start(gr))
tp <-function(gr)ifelse(strand(gr)=='-',start(gr),end(gr))
strandshift<-function(gr,shift)shift(gr , ifelse(strand(gr)=='-',- shift,shift))

for(fname in lsf.str('package:dplyr')) assign(fname,get(fname,'package:dplyr'))

source(here('src/R/Rprofile.R'))

argv <- c(
	bam = here('pipeline/star/data/E13_ribo_2/E13_ribo_2.bam')%T>%{stopifnot(file.exists(.))},
	gtf = here('pipeline/my_gencode.vM12.annotation.gtf'),
	outfolder = 'riboWaltz/E13_ribo_2.bam/'
)

sample_params<-here::here('src/sample_parameter.csv')%>%fread%>%filter(assay=='ribo')%>%.$sample_id
bams <- paste0('star/data/',sample_params,'/',sample_params,'.bam')%>%map(. %T>%{stopifnot(file.exists(.))})

argv[] <- commandArgs(trailing=TRUE)

for (nm in names(argv)) assign(nm,argv[[nm]])

REF <- here('pipeline/my_GRCm38.p5.genome.chr_scaff.fa')

#get exons
gtf_gr<-mimport(con=gtf,format='gtf')

# if(!is('exons','GRanges')) exons <- gtf_gr%>%subset(type=='exon')
# if(!is('cds','GRanges')) cds <- gtf_gr%>%subset(type=='CDS')
# if(!exists('startcodsa')) startcods <- gtf_gr%>%subset(type=='start_codon')
exons <- gtf_gr%>%subset(type=='exon')
cds <- gtf_gr%>%subset(type=='CDS')
startcods <- gtf_gr%>%subset(type=='start_codon')

#First select some top exons for the offset finding process
c(topcdsexons,topcdsmap) %<-% get_top_trs(bam,exons,cds,startcods)

#get reads over them
readtopreads<-function(bam,top_cds=topcds){bam%>%BamFile(yieldSize=NA)%>%readGAlignments(param=ScanBamParam(which=top_cds))}
readtopreads<-mymemoise(readtopreads)
topcdsreadsbak <- bam %>% readtopreads
topcdsreads<-topcdsreadsbak


compartments <- get_compartments(cds,DEFAULT_CIRC_SEQS)

topcdsexons$compartment <- get_transcript_compartments(topcdsexons,compartments)

cdsread_trmap <- get_cdsread_trmap(
	topcdsreads,
	topcdsexons,
	topcdsmap
)

#get the cds offsets, and export them
c(bestscores,offset_cds_scores) %<-% get_offsets(cdsread_trmap,compartments)

outfolder%>%dir.create(showWarnings=F,rec=T)
bestscores%>%write_tsv(file.path(outfolder,'cdsmax_offsets.tsv'))

#get the cds shfit offsets for our data
cdsread_trmap$cdsshift <- apply_cds_offsets(cdsread_trmap,bestscores)

#get only those with a define shift, and for which this doesn't put them over the edge of tr
cdsread_trmap <- cdsread_trmap %>% subset(!is.na(.$cdsshift)) %>% intersect(.,trim(.))

stoppsites <- get_stop_sites(cdsread_trmap,topcdsmap,STOPWINDOWSTART,STOPWINDOWEND)

data4readshift <- get_seqforrest_traindata(stoppsites,topExonseq)

shiftforrestfit <- get_seqoffset_model(data4readshift)

cdsread_trmap$seqshift <-  get_predictedshifts(shiftforrestfit,data4readshift)
# })()
```

## Testing

We can see if our procedure worked by quickly looking at the fft (fast fourier transform) on the top1k genes
binned randomly into 5 groups, before and after the application of our sequence specific cutoffs (to ALL reads),
rather than just those around the stop codon

```{r }
get_periodicity_scores<-mymemoise(function(cdstosamp,cdsread_trmap){
	message('.')
	assert_that(has_name(mcols(cdsread_trmap),c('seqshift','cdsshift')))
	psites2use<-cdsread_trmap%>%
		keepSeqlevels(cdstosamp,'coarse')%>%
		resize(1,'start')%>%
		shift(.$cdsshift)

	topcdsmap%<>%setNames(.,as.character(seqnames(.)))
	cds2use <- topcdsmap[cdstosamp]

	periodicfrac<-cdscov(psites2use,cds2use)%>%get3bpfrac

	data_frame(
		no_seqshift = psites2use%>%cdscov(cds2use)%>%get3bpfrac,
		with_seqshift = psites2use %>% shift(-.$seqshift)%>%cdscov(cds2use)%>%get3bpfrac
	)
})


cdscov <- function(reads2use,cds2use) coverage(reads2use)[cds2use]%>%unlist%>%as.vector

get_frac_inds<-function(vect,l,r){
	lind <- floor(l*length(vect))
	rind <- floor(r*length(vect))
	vect[lind:rind]
}
# get_frac_inds(1:20,0.3,0.36)
get3bpfrac<-function(x) x %>%
	# add(c(1000000,0,0))%>%
	fft%>%
	abs%>%
	`^`(2)%>%
	{sum(get_frac_inds(.,0.3,0.36))/sum(.) }


seqshift_periodicities<- seqnames(cdsread_trmap)%>%
	unique%>%
	as.character%>%
	split(seq_along(.)%%5)%>%
	lapply(F=get_periodicity_scores,cdsread_trmap)%>%
	bind_rows

```
```{r spectral_coefficient_strip_plot, fig.width =4,fig.height=4,out.width=400,out.height=450,dev='pdf',include=TRUE,eval=TRUE}
seqshift_periodicities%>%gather(set,spectral_coefficient)%>%qplot(data=.,x=set,color=set,y=spectral_coefficient,geom=c('point'))+theme_bw()

#Get riboqc_cutoffs
sample = bam%>%dirname%>%basename 
riboqccutoffs <- str_interp(here('pipeline/riboqc/data/${sample}/_P_sites_calcs'))%T>%{stopifnot(file.exists(.))}
riboqcdf <- riboqccutoffs%>%fread%>%select(length=read_length,riboqc_shift=cutoff)



fcods=20
lflank=(fcods*3)
rflank=(fcods*3)+2
mpoint=((fcods*2)+1)*3
epoint=((fcods*4)+2)*3

# cdsread_trmap%>%as.data.frame%>%mutate(d=startdist+stopdist)%>%.$d%>%hist
# cdsread_trmap%>%as.data.frame%>%mutate(d=startdist+stopdist)%>%.$d%>%between(-lflank,rflank)%>%table
metaplotlabs<-c(paste0('-',lflank/2),'AUG',lflank/2,paste0('mid -',lflank/2),'mid',paste0('mid +',lflank/2),paste0('end -',lflank/2),'stop',paste0('end +',lflank/2))
metaplotbreaks<-c(-lflank/2,0,lflank/2,mpoint-lflank/2,mpoint,mpoint+lflank/2,epoint-(lflank/2),epoint,epoint+(lflank/2))
#
seqshiftfuncs <- list(
	Riboqc = .%>% safe_left_join(riboqcdf,by=c('length'))%>% mutate(startdist=startdist+riboqc_shift,stopdist=stopdist+riboqc_shift),
	CDSmax_shift = .%>% mutate(startdist=startdist+cdsshift,stopdist=stopdist+cdsshift),
	seqshift = .%>% mutate(startdist=startdist+cdsshift,stopdist=stopdist+cdsshift)%>%mutate(startdist=startdist-seqshift,stopdist=stopdist-seqshift))
#
```

We can also simply look at a metaplot of the frames, (comparing riboqc and cdsmax shift)

```{r }
plist=lapply(seqshiftfuncs,mymemoise(function(seqshiftfunc){
	#
	p=cdsread_trmap%>%
		# sample(100e3)%>%
		# shift(.$cdsshift)%>%
		mcols()%>%as_tibble	%>%
		select(startdist,stopdist,length,cdsshift,seqshift)%>%
		# filter(between(abs(startdist-stopdist),-lflank,rflank))%>%
		seqshiftfunc%>%
		mutate(
			mdist = startdist - ((floor(((startdist-stopdist+1)/3)/2))*3),
			instart=between(startdist,-lflank,rflank),
			inend=between(stopdist,-lflank,rflank),
			inmiddle=between(mdist,-lflank,rflank)
		)%>%
		filter((instart|inend|inmiddle) & (!(instart&inend&inmiddle)))%>%
		# filter(instart)%>%
		mutate(x = NA,
			x=ifelse(instart,startdist,x),
			x=ifelse(inmiddle,mdist+mpoint,x),
			x=ifelse(inend,stopdist+epoint,x) ) %>%
		mutate(length=as.character(length))%>%
		bind_rows(.,mutate(.,length='all'))%>%
		group_by(x,length)%>%tally%>%
		# filter(length=='all')%>%
		mutate(phase = factor(x%%3))%>%
		# arrange(desc(n))
		ggplot(aes(x=x,ymax=n,ymin=0,color=phase))+geom_linerange()+
		facet_grid(scale='free',length~.)+
		geom_vline(linetype=2,xintercept=c(0,epoint+2),alpha=I(0.3))+
		scale_x_continuous(labels=metaplotlabs,breaks=metaplotbreaks)+
		# coord_cartesian(xlim=c(-lflank,rflank))+
		geom_rect(aes(xmin=0,xmax=epoint,ymin=0,ymax=Inf,alpha=I(0.01)),fill='grey',color='white')+
		scale_fill_discrete(guide=F)+
		theme_minimal()	
	p
}))

```
```{r riboshift_comparison plot, fig.width =12,fig.height=12,out.width=1200,out.height=1250,dev='pdf',include=TRUE,eval=TRUE}
ggpubr::ggarrange(ncol=3,plotlist=plist,labels=names(seqshiftfuncs))
```

.... All of which seems to indicate our procedure is doing a better job of recovering actual P-site positions. Note that it's p
site positions are consistent between reads - no dramatic difference between 28 and the others - and manage to recover periodicity
in specific read lengths where it was missing. 

I remain a little concerned by how the stop codon isn't quite in the CDS for some of these...
We could try choosing our set such that things only have negative shifts - doesn't work as well though (also weirdly ruins periodicity for 26bp)


```{r }
here('reports')%>%dir.create

if(!isTRUE(getOption('knitr.in.progress'))) '/fast/work/groups/ag_ohler/dharnet_m/cortexomics/src/R/rf_offsets.R'%>%{rmarkdown::render(knitr::spin(knit=F,.),output_file=here('reports',basename(str_replace(.,'.R$','.html'))))}
```

